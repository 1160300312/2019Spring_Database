# **1.问题描述**

在很多情况下，时间序列数据中都有很强的短期依赖关系（temporal dependence），即在时间序列数据中某个时间点前后的数据有着很强的相关性。合理运用这些短期相关性有着很多的应用场景。如分析商场中的不同因素对用户购买情况的影响，或者帮助用户分析投资组合情况，再者，合理的运用还能够对用户的行为进行预测。为了说明这个问题，可以举下面这样的例子。

****

**例一.** *对于一个投资组合，找到每周的交易量和接下来几周的平均股价变化的关系。*

****

例一的需求其实就可以看作探究在当前交易量和平均股价变化的短期依赖关系，其中当前交易量是致使行为（causative behavior）,平均股价的变化是依赖行为（causative behavior）。在短期依赖关系的定义中，致使行为就是指影响用户未来行为的那些因素，依赖行为就是值由致使行为引起的那些行为。

对于用户的行为分析，有一种已经存在的表现的也算比较好的算法叫做同期群分析法（Cohort Analysis）。这种方法首先被应用在社交科学中，最近在网络用户行为模式分析中也有比较好的结果。同期群分析实现起来也比较简单，主要通过两方面来衡量用户的行为：社会行为的变化（social change）和时效（aging），在这个模型中认为这两方面合主要影响了用户的行为。为了捕获社会行为的变化，这个方法将具有相同特征的人放在同一个群（cohort）中，如做一个特定的事件的时间和地点。然后在每一个群中衡量不同时间下用户的行为从而反映出对时效的影响。

但是，对于发现短息依赖关系而言，同期群分析也有很多的缺陷。首先，时效的定义知识通过简单的出生时间来定义，这就大大降低了定义致使行为的灵活性；而且，同期群分析一般定义用户的出生就是指用户的生日，这是不会变化的。但是实际上，在不同的时间，用户很有可能会产生不同日期连续的致使行为，这些是都需要被考虑在内的。如在例一中提到的，在股市交易中，每个股票的价格都是持续变化的，如果只考虑第一周的股票的价格在很多情况下是不具有参考性的。

所以，作者提出了递归的同期群分析（recurrent cohort analysis），它解决了同期群分析的一部分缺陷。这个方法通过定义如何进行分片，以及定义滑动的时间窗口，来将行为分析定义在窗口中。然后通过一系列的群操作（cohort operators）来对初始的eventT模型进行转换，得到最终可以分析短期依赖的模型。最后，再对模型中可挖掘的并行充分利用，并给出了适配于分析的并行架构。

# **2.算法描述**

## **2.1 时间窗口的实现**

重构的同期群分析的核心就是如何来衡量致使行为和依赖行为。为了衡量这两个行为，首先定义如何进行时间分片，并在这个基础上定义滑动时间窗口，即包含连续的时间分片的集合，并且可以随着分析进行滑动。建立时间窗口的过程中，首先使用一个叫eventT的表，其中包含了每个用户的每个行为。它主要有两列构成：用户和时间，记录了谁在什么时候做了什么动作。其中动作可以单独为一列，也可以不包含动作。

### **2.1.1 时间分片**

为了能随时间动态地衡量致使行为和依赖行为，我们需要将时间序列数据分片，每片代表分析的最小单位。简单的分片方法可以是将数据按时间分为等长的数据片，但是显然这样满足不了大多数情况下的要求。因此定义了下面的方法来进行分片。

**定义1.** *时间的划分，如P所示*

$$P=\left\{\begin{array}{cc}
(A,C), & if\ A=event\\
(A,U), & if\ A=time \\
(A), & otherwise
\end{array}\right.$$

*其中A表示eventT的一个分布，C是eventT的一个可选的分布公式，表示A的一个按event的划分，U是一个时间集合，表示对时间的划分。*

**定义2** *对于一个给定的划分P，可以将用户u的时间划分为如下的分片：*

$$S_u=\{[t_i,t_{i+1})|i\geq0\wedge t_i\in D\wedge t_{i+1} \leftarrow min\{t|t\in D \wedge t>t_i\}\}$$

$$D=\left\{\begin{array}{cc}
\{d_{u,i}[time]|i=1\vee P.C(d_{u,i}=true)\}, & if\ P.A=event\\
\{d_{u,i}[time]|i=1\vee d_{u,i}[P.A]\neq d_{u,i-1}[P.A]\}, & if\ P.A\notin \{event,time\}
\end{array}\right.$$

*其中$d_{u,i}$表示u用户按时间顺序表现出的第i个状态，$d_{u,i}[A]$表示状态对应的A列的值。对于这个表示，$S_u$的第i个时间分片，就是对应的$[t_{i-1},t_i)$，用$S_{u,i}$来表示。*

简言之，对于这个时间分片的划分，如果P是时间，那么对于分片的分割就是P.U对应的时间的划分；如果P是event，那么分割的界限有P.C对应的对于event的划分得到；如果二者都不是，就在时间序列数据中对应的数据变化的部分设置分割得到分片。

### **2.1.2 时间窗口**

通过时间分片，我们得到了一系列的片段。基于这些片段进行动态分析，我们其实已经能够进行简单的短期依赖关系分析了。而且，我们还能够通过分片来推断出这个片段属于致使行为还是依赖行为，并分别对其进行分析能够得到一部分结果。但是，这样就限制了我们只能够每次值衡量一个时间分片的内容。但恰好在很多情况下这种限制是很致命的。比如说例一，如果我们想知道近五周的股票交易量如何影响股票未来的价格，我们就需要对五个时间分片进行分析，这样只用一个分片的情况就无法满足我们的要求了。

对于比较自然的想法，我们可以定义时间窗口为一个可配置长度的包含这连续时间片的窗口，这样我们就可以让这个窗口进行滑动，来满足我们的要求。如当窗口长度为$l$滑动到分片$S_{u,i}$时，这个窗口就包含分片$(S_{u.i-l-1},\cdots,S_{u,i})$。虽然这样的定义已经能满足我们的大多数要求，但是仍存在无法解决的问题。仍拿例一举例，如果我们想了解那些比上一周股票价格高的周对交易量的影响，这样的模型就无法满足我们的要求了。因此，我们按照如下的方式来定义时间窗口。

**定义3.** *时间窗口W的定义如下所示：*

$$W=(P,W^l,W^h)$$

*其中P在定义1中有定义，对于这个窗口，它会滑动到$S_{u,i}$位置。$w^l$和$w^h$是用于确定窗口区间的两个整数。这个窗口中的分片定义为$T_{u,i}$，如下所示*

$$T_{u,i}=\{S_{u,j}|f(i,w^l)\leq j\leq f(i,w^h)\}$$

*其中方法f如下所示*

$$f(i,w)=\left\{\begin{array}{cc} w, & if\ w>0\\ i+w, & otherwise \end{array}\right.$$

*对于$T_{u,i}$，我们定义$S_{u,i}$为这个时间窗口的位置。*

定义3中对于时间窗口的定义就很好地解决了我们前面提到的那个限制。这样定义不仅允许我们设置窗口包含的分片的多少，还能够定位窗口包含的分片的位置。根据等式2，如果定义的$w^l$为正数，那么窗口中最开始的分片即为$S_{u,w^l}$，这样就和位置无关了。如果$w^l$为0或负数，$w^l$就会随着窗口的滑动，不断改变，这种情况也就能处理我们先前举的那个例子了。

### **2.1.2 时间窗口的属性**

定义3中的时间窗口已经能够满足我们动态选择时间分片的需求了。那么对于滑动过程中时间窗口选择的那些时间分片，我们还需要定义我们要对这些分片做的动作，这个过程可以定义为时间窗口属性的衡量，定义如下。

**定义4.** *一个时间窗口属性A定义如下*

$$A^t=(F,A,W)$$

*其中$f$是一个合计方法，即对这个窗口中的所有分片进行计算的操作；$A$和定义1中出现的$A$一致，是表示用户活动的eventT表；$W$表示被计算属性的窗口。*

这样的定义中，属性是定义在一个窗口上的，这样就限制我们只能在一个窗口上来计算相关的属性。仍拿例一举例，如果我们要计算股票交易量的变化，我们就需要计算当前周的窗口计算的贸易量的值和前一周的贸易量的值作差，这就要求我们定义两个窗口属性$A_1^t$和$A_2^t$，其中$A_1^t.W.w^l=A_1^t.W.w^h=0$表示当前窗口，$A_1^t.W.w^l=A_1^t.W.w^h=0$表示当前窗口前的一个窗口。这样我们就能通过计算$A_1^t-A_2^t$得到我们需要的结果。但是，如果我们的需求是对每周的贸易变化量求平均的话，那么我们仍然单独对每个窗口做操作定义的复杂程度就会很高，因此，可以定义综合时间窗口属性（Composite time window attribute）和复合窗口属性（Compound time window attribute）。

**定义5.** *综合时间属性是值在*一个或多个具有共享的底层划分的窗口上做计算得到的一种属性。

**定义6.** *复合时间属性的定义和定义4中定义的等式相同，但是其中的A不再是一个eventT表，而是和$W$具有相同窗口划分的时间窗口属性集合。*

通过这两个定义，我们就能够很好的处理刚才提到的那个例子。自此，我们就完成了我们对时间窗口的定义。时间窗口在这个算法中有着中心的地位，这是动态地衡量用户行为的基础。

## **2.2 递归同期群分析（Recurrent Cohort Analysis）**

### **2.2.1 用户行为的衡量**

前面在定义窗口的过程中其实我们已经可以随着窗口的滑动对每一个窗口来进行相应的计算了。但是这样的定义仍不完全，因为我们没关注我们可能对哪些行为是感兴趣的哪些是不感兴趣的，而是对于所有的窗口都是统一的定义。这样其实在很多情况下是无法满足需求的。仍拿例一举例，如果我们希望衡量某个时间前一个用户的所有行为的话，我们就无法通过之前的模型来实现了。因此，我们在衡量用户行为，滑动窗口的过程中就需要对我们不感兴趣的窗口进行过滤。

**定义7.** *用户行为衡量$M$如下定义*

$$M=(C^e,C^w,A^t)$$

*和前面对分片的定义相同，$C^e$是是eventT的一个可选的分布公式；$C^w$是一个衡量公式，能以一个或多个窗口作为输入，判断其是否满足公式的需求；$A^t$是表示用户行为的时间窗口分布。*

这样，我们就定义了如何对用户的行为进行衡量。在窗口滑动的过程中，如果$C^w$衡量这个窗口为真，那么$A.f$对应的行为就会施加到这个窗口上，否则就继续滑动。

### **2.2.2 递归同期群分析**

**定义8.** *递归同期群分析的的定义如下*

$$(M^c,M^d,[A^{tg}])$$

*其中$M^c,M^d$是用户行为的衡量，分别表示对致使行为和依赖行为的衡量。$A^{tg}$是一个可选的时间窗口属性，它用来和给定致使行为相关的每个依赖行为的年龄（age）*

在这样的定义中，$M^c$决定了每一个用户数据是否被加入到被分析的队列中。在每个$M^c.C^w$为真的窗口处，这个用户数据就被加入到分析队列中表示这些数据要被当作致使行为来衡量。

致使行为的衡量$M^d$和$M^c$有一些不同，它衡量的是用户数据在加入不同队列后在那些相同的队列中的用户的聚簇行为。

## **2.3 递归同期群分析的操作符**

这部分主要介绍了同期群分析过程中不同表的转换，从eventT表转换到resultT表。每次转换都将致使行为和依赖行为之间的短期依赖重新建立。这部分假设$M^C.C^e$和$M^D.C^e$都为空，表示他们都是不重要的因素。各种表以及它们之间的转换如图1所示。

**图1**。

### 窗口滑动操作符$\gamma$

窗口滑动操作符首先将eventT转换到sliceT，sliceT中记录了每个用户数据的时间分片。然后产生windowT包含了每个用户在滑动路径上产生了所有的窗口，日期来记录了每个用户数据的开始时间wlow和结束时间whigh，以及每个时间分片的位置wpos。

### 窗口聚合操作符$\phi$

窗口聚合操作符用来衡量在窗口滑动过程中的每个用户个体的行为。如图1所示，这个操作符有两个目的。一个是衡量每一个用户数据的知识行为，得到表cohortT，到的衡量结果存在这个表的cohort列中。另一个是输出每一个用户在每个位置的年龄（age）到winAgeT表中，得到的值存在age列中。

### Age-by操作符$\psi$

对于每个用户以及被它加紧每个队列的数据，age-by操作符就是简单地将滑动过程中的每一个位置和由$A^g$决定的年龄联系到一起。对于默认的情况，$A^g$就是指窗口已经滑过的位置数，我们能够很容易对windowT和winAgeT进行修改和替换得到这个操作符的实际意义。

### 递归聚合操作符$\omega$

对于递归同期群分析而言，我们首先对于每个年龄建立队列，所有的有着相同年龄的用户动作都在同一个队列中。然后我们使用整合函数计算每个年龄和队列对应的依赖关系，这样我们就建立起了我们想要的短期依赖关系。

这上面的定义中，我们都是假定$A$是一个eventT的分布。如果它是不是eventT而是一种其他的分布，我们就需要对我们的操作符使用顺序进行变更。首先需要窗口聚合操作符来衡量在滑动过程中每个用户在每个位置的分片，然后将结果分布到cohortAgeT中。然后接下来我们就能正常使用得到的cohortAgeT表继续进行分析了。

### 查询计划（Query Plan）

通过上面的一系列操作符，我们就可以定义一个操作序列来执行递归同期群分析了。如图2所示，其实，对于同期群分析来说，我们只需要将顺序执行操作符即可，不必有很复杂的逻辑。其中，窗口聚合操作和选择操作符都要执行两次鉴于对致使行为和依赖行为的不同计算方法。但这些都基于我们假定致使行为和依赖行为的底层分片划分是相同的。否则，如果对于时间分片有多种配置的画，我们就需要执行多次窗口聚合操作。

**图2**。

## **2.4 操作符实现和评测**

为了评估操作符，这里选择两种方法。一种是通过将这些操作符对应的计算过程转化为SQL语句在数据库中直接进行操作。另一种是通过侵入策略（Intrusive Strategy）来实现的，作者将操作符的运算扩展到基于COHANA的架构中。

### **2.4.1 基于SQL的策略**

以sliceT为例，其他的操作符实现都能通过定义进行类似而且简单的操作得到。正如前面的说明，对于每一个给定的$P$, sliceT记录了每一个用户数据分片的结果。因此，对于sliceT的计算主要就是通过$P$来计算得到所有的分割界限。对于$P.A\in \{time,event\}$，我们只需要通过SQL内置的选择操作得到我们需要的结果；对于$P.A\notin \{time,event\}$的情况，我们对分隔符的计算是通过按照时间顺序是否发生变化来得到的。这时候我们首先使用SQL的排序指令，然后使用一次自连接，连接条件是如下所示的$\theta$
$$\theta=T_1.user=T_2.user\wedge T_1.A\neq T_2.A\wedge T_1.rank=T_2.rank+1$$
其中$T_1$和$T_2$都是eventT中的参数，$A$是$P$中定义的。

对于基于SQL的策略，我们可以对其进行一定的优化，由于我们可能会在同一个数据上进行多次相同的分片，我们可以将得到的分片结果（或者其他结果）持久化到硬盘中，这样我们再次访问到这个操作的时候就可以通过访问磁盘来减少运行时间。这是典型的利用空间来换取时间的做法。对于持久化到哪里，我们可以将得到的结果存到相应的表中，即在相应的表中添加相应的列，来实现我们的需求。

### **2.4.2 侵入策略（Intrusive Strategy）**

侵入策略是指作者设计出一个适合于之前定义的操作符的底层，以及在这之上定义一系列的基础操作，然后通过这些高效的基础操作的组合来实现每一个操作符的功能。

首先，这个实现是基于COHANA的存储底层的。然后这个系统存储eventT表是将每一个用户数据聚集在一起，并按照时间先后顺序存储。然后将这些数据分成相同大小的桶进行存储。然后对于每一桶，都定义了类似于**getNextTuple**，**getTuple**和**skipTo**等接口来按顺序访问每一个用户的时间顺序的数据。

然后，基于这个存储底层，作者除了实现简单的常用聚集函数如SUM，MIN，MAX，COUNT和AVG外，还实现了**getSlices**，**getMaxTime**，**getMinTime**和**getValue**等接口。其中**getSlice**接口返回当前用户对应的分片数；**getMaxTime**和**getMinTime**分别返回给定的滑动窗口的位置的上界和下界；**getValue**接口返回给定位置窗口的属性值。这些算法的一个比较自然的实现如图3所示。

**图3**。

## **2.5 分布式架构**

在侵入策略中，每个用户对应的动作都存在同一个桶中，这样我们就可以利用存储方式的固有优势来对我们的处理过程进行分布式计算。而且，因为不同的桶计算在大多数情况下是不需要信息交换的，所以也不需要考虑同步的问题。

现有有很多分布式架构，但是这些分布式架构实现前面提到的操作符都比较复杂。而且这些分布式框架都为了实现安全的消息传递机制而实现了很复杂的架构，这对于递归同期群分析都是没必要的。因此，作者实现了一个简单但是适用于递归同期群分析的分布式架构。

系统的架构如图4所示。底层是分布式存储器，每个存储器都存储这相同大小的桶。顶层是一系列的进行运算的workers以及一个控制器master，master是从workers中选出的。这些都是由Zookeeper来控制的。数据的存放是通过round-robin来实现的，因为数据之间官赖女性不大而且round-robin能够实现很好的负载均衡。

**图4**。

对于master,当收到一个新的任务时，master只需要简单的将任务分发给所有的worker，然后等待恢复。一旦所有的worker都计算完成后，就合并所有的计算结果传给用户。worker的运行也十分简单，每个worker加载它本地的数据，然后直接将数据拷贝到内存中进行相关的计算即可。

分布式架构一定要考虑出错问题。对于这个分布式框架，当一个worker失效被Zookeeper发现，它就会通知Master把这个失效的worker的工作分配到现在仍工作着的worker中，然后重新发送需求重新计算。这样会导致收到多个回复的问题，我们可以通过给每一个需求一个id来实现，对于同一个需求收到的多个回复，我们只保留对应的id大的结果。如果master失效，Zookeeper会重新在worker中选择新的master继续执行。

# **3. 一个例子**

我们通过举一个例子来说明这个算法。我们仍考虑例一中的问题，不过我们做一些改变，我们考虑股市交易量中的10周移动平均线上的5周移动平均线（moving average）。首先，我们需要构造两个时间窗口属性，记作$A^t_1$和$A^t_2$，分别用来计算近5周的平均价格和近10周的平均价格。然后我们还需要定义窗口，分别定义为$A^t_1.w^h=A^t_2.w^h=0$，$A^t_1.w^l=-4$，$A^t_2.w^l=-9$,分别表示窗口对应的相对位置，而且长度为5和10。除此，我们还需要另外的两个时间窗口属性$A^t_3$和$A^t_4$，二者窗口的定义分别为
$A^t_3.w^h=A^t_4.w^h=-1$，$A^t_1.w^l=-5$，$A^t_2.w^l=-10$。然后根据我们的需求，我们可以定义$C^w$为$A^t_1>A^t_2\wedge A^t_3<A^t_4$，然后我们可以定义致使行为为$(\empty ,A^t_1>A^t_2\wedge A^t_3<A^t_4,A^c)$，其中$A^c$计算当前周的交易量，所以$w^l=w^h=0$。

对于致使行为而言$M^d$而言，我们需要对每一个队列求平均，而且还要求相同年龄的周的价格的平均。因此，我们需要建立一个综合时间窗口属性。在一个综合时间窗口属性中，我们要计算价格变化$A^t_5-A^t_6$，其中$A^t_5$和$A^t_6$分别计算当前周和先前周的价格，所以$A^t_5.w^h=A^t_6.w^h=0$，$A^t_5.w^l=A^t_6.w^l=-1$。这样，我们的综合时间窗口可以这样$A^d_t$就可以这样定义：$(f,A^t_5-A^t_6,W)$，其中$f$是求平均的方法，$W$定义为$W^l=W^h=0$。而且，因为$M^d$中没有定义$C^c$和$C^w$，我们就可以将$M^d$表示为$(\empty,\empty,A^t_d)$

然后，对于通过操作符对表进行转换得到结果，其实我们在得到窗口定义和衡量定义以后就可以对例子进行模拟了，操作符表是一个系统
的定义和转换过程，定义已经讲的比较清除了，不再这里进行赘述。

# **4. 相关研究**

对于传统的同期群分析，它主要研究两点因素如何影响用户的行为：社会行为的变化和时效。传统的同期群分析已经被很广泛的应用了，如社会调查、健康管理等。这些分析主要是通过统计的方法来实现的。传统的同期群分析在【】【】中有实现，这个方法主要通过实现三个定义的操作符以及在COHANA底层实现。

对于短期相关性（temporary dependence）的检测，在分析和处理时间序列数据的过程中经常提到，而且也有很多不同的方法来实现。这篇文章【】通过对时间序列数据的子序列进行聚类，聚类通过对托普利兹矩阵的一系列计算转换得到，然后将得到的每一个簇，定义成一个马尔科夫随机场，在不同的观测结果中将数据内部的依赖关系中表示出来。最终，将多维时间序列数据成为一个明确的线性时间线。

另一篇文章【】将重点放在发现短期相关性并将时间序列数据的预测上，作者提出了基于regime shifts检测的非线性时间序列时间建模方法，主要将终点放在作者定义的三个要素上：1.挖掘潜在的非线性系统变化过程；2.识别检测regime在时间上的变化；3.多规模的时间序列嵌套结构建模。这个文章中的系统主要通过更新参数生成事件、新模式参数估计、未来事件的预测来发现相关性并对未来进行预测。

还有方向是通过建立有穷状态机【】【】来实现的。将时间序列数据通过滑动窗口分成相同长度的子串，然后在训练过程中建立状态机模型，每个状态都对应着一个当前的相关性，然后对于给定的时间序列数据，可以从起始位置线性扫描得到每个过程的状态（相关性）。除了相关性的挖掘，有穷状态机还可用于时间序列异常值的发现和处理，

这些方向都有着类似的目标，那就挖掘出时间序列中的temporary dependence，但是使用的方法却有着很大的不同。以传统同期群分析和这篇文章提到的递归同期群分析为代表的分析方法通过建立分析表来进行活动分析得到短期依赖，实现起来简单，实用；以聚类等无监督模型以及分类等为代表的通过数据分片并建立衡量不同分片之间距离（相似度）来得到簇并对簇进行分析得到依赖关系，模型固定，可选择性高；以统计的线性模型诸如卡尔曼滤波方法，线性动态系统建模实现依赖关系挖掘进行预测的，或者是通过测试复杂度线性的有穷自动机等等，他们都各有优劣，对于具体的数据模式或者需求场景，都应选择适合的方法。

# **5.已有算法的不足和改进**

## **5.1 已有算法的不足**

通过聚类方法来挖掘时间序列数据的相关性固然可用，但是在聚类过程中如果不加其他操作的话，很容易就会在聚类过程中丢失了时间序列的时间维度，而时间恰是时间序列数据中很重要的部分。或者，我们可以通过对时间数据进行分片后再进行聚类，或者加如特定的标记来将时间作为聚类的一个维度等，实际操作下很难有好的结果。而且对于聚类方法来说选择一个好的距离衡量方法也很重要，对于不同的数据类型如果未定义好普适的距离衡量方法，可能会出现在不同的数据上结果质量参差不齐的情况。

通过对数据分片然后使用统计方法固然可高效地获得可用的短期相关性结果，但是建模过程一定是假定了数据满足既定的分布，这种模型也很难做到普适性，对于不同的数据其分布状态极有可能不同。

然后将目光转移到同期群分析和本文提到的递归同期群分析中。对同期群分析来说，它只定义了单个的出生事件，即如果一个用户数据的出生是由多维的事件来决定的，它将不再适用。而且，它遵从短期年龄定义（temporary age definition），这就限制了它的使用。对于这篇文章中提出的递归同期群分析中在一定程度上解决了这个问题，但我认为这个算法中仍存在一定的缺陷。首先，在文章中实际解释执行的操作符定义中，$M^c.C^e$和$M^d.C^e$都被认为是空的，而且还假定$M^c$和$M^d$具有相同的窗口划分，这点要求其实就忽略了$A=event$的情况，而且要求窗口划分相同的要求在很多情况下都有可能不允许，如果这一点不满足的话，在之后的研究中无论是操作符的定义还是需求计划都要变得复杂。除此，在窗口聚合操作符的定义中，文章中只考虑了定义4中的窗口属性，对于定义5和定义6中的复合窗口属性，我们应该需要更多的操作来实现。而且，作者提到的分布式架构中的错误处理上，只考虑了worker和master故障，而并未考虑存储节点出现故障或者Zookeeper出现故障。除此，对于将所有的worker计算的结果都交付到master，接受完全以后再交付给用户，单点负载会特别大，影响效率而且很有可能master存储不下。

## **5.2 解决方案**

对于聚类方法而言，我认为有很大一部分是聚类存在的固有问题，比如说使用梯度下降等收敛慢，或者其无监督性等。但是对于不同的数据使用不同的距离衡量方式这种，我觉得可以通过建立一种模型能够解决。对于所有已有的时间序列数据库，我们可以将对其作用最好的距离衡量方法作为训练数据，然后对于新的要衡量的时间序列的格式或者特征，通过这些特征输入模型中得到最适合这个时间序列格式的距离衡量方法。我查找了相关文献，果然有人已经做了类似的方面。这篇文章【】
中作者提取出了时间序列数据库的多维特征并且训练一个分类模型来找到最适合的距离衡量方法。

而且，我觉得，对于通过建立概率模型寻找短期依赖的方法中关于使用何种模型的方法也能通过建立一个类似的分类模型来实现。提取出时间序列数据库的有关特征，并训练模型。不同的是我们提取的特征需要和概率模型有关。

对于递归同期群中提出的问题，对于定义不完善的那部分，我觉得对于操作符的转移不需要做改变，需要做的是查询计划的那部分。因为窗口划分的不同所以对于查询计划的一些操作是无法进行合并的，因为得到的结果都不尽相同，需要多做一些操作才能获得正确的结果。对于分布式架构的方面，首先，如果存储节点故障，数据就会丢失，那么我们需要对存储节点的数据进行一定的冗余存储，如设置一定的冗余参数，如果数据冗余量少于一定程度时自动进行冗余存储操作等。如果ZooKeeper故障，虽然不会影响正常执行，但是也应该也有备用的ZooKeeper来防止出现故障。对于单点瓶颈问题，我觉得将结果直接传给master是不理智的一种做法。我觉得这个问题可以通过worker分层传输来解决，添加一定的消息传递机制，将worker得到的结果发送给高层的worker，高层的worker用于保存结果，然后传给master一个索引，master拿到所有的索引以后按照索引将结果流传送给用户。这点可能就打破了作者说的无需worker间通信的说法，但是我认为是很有必要的。

# **6. 参考文献**

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });
</script>